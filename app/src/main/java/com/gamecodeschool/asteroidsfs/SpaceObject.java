package com.gamecodeschool.asteroidsfs;

import android.graphics.PointF;

/* 
 * The SpaceObject class represents a moving object in space. We need position to track this object
 * on screen. The position is center of object with float (x,y) coordinate. We would prefer
 * int but float works better with some of the other android API.
 * We have overall speed magnitude (doesn't have direction) component x and y
 * can be generated by multiplying with angle(radian) to get (x,y) component of the vector.
 * The instead of using RectF as suggested by text, we shall use radial sum vs distance 
 * of object comparison.
 */

public class SpaceObject {
    // These must be protected since Spaceships (player / enemy) can modify their movements.
    protected PointF position;
    protected float velMagnitude;
    protected float hitRadius;
    protected double angle; // in radians!

    SpaceObject(PointF pos, double angle, float velocityMagnitude, float hitRadius) {
        // BEGIN LEGACY CODE. Needs to be phased out for later stage.
        position = pos;
        velMagnitude = velocityMagnitude;
        this.hitRadius = hitRadius;
        this.angle = angle;
    }

    // This constructor allows a copy of the object to be made
    SpaceObject(SpaceObject cpy) {
        position = new PointF(cpy.position.x, cpy.position.y);
        velMagnitude = cpy.velMagnitude;
        hitRadius = cpy.hitRadius;
        angle = cpy.angle;
    }

    
    public PointF getPosition() {return position;}
    // Following two getters returns coordinate for top left corner for bitmap. When used together.
    public float getBitmapX() {
        return position.x - hitRadius;
    }
    public float getBitmapY() {
        return position.y - hitRadius;
    }


    // Default position update based on time.
    public void update(long time, final Display screen) {
        // UPDATING NEW POSITION VARIABLE.
        position.x += velMagnitude * Math.cos(angle) * time;
        position.y += velMagnitude * Math.sin(angle) * time;
        // Check when objects get to edge of the screen to wrap around
        if(position.x < 0)
            position.x = screen.width;
        else if(position.y < 0)
            position.y = screen.height;
        else if(position.x > screen.width)
            position.x = 0;
        else if(position.y > screen.height)
            position.y = 0;
    }


    // two circles if the sum of radius is greater/equal distance between two center coordinates.
    static boolean collisionCheck(SpaceObject A, SpaceObject B) {
        double radialSum = A.hitRadius + B.hitRadius;
        double distance = Math.sqrt(Math.pow((A.getPosition().x - B.getPosition().x),2)
                                + Math.pow((A.getPosition().y - B.getPosition().y),2));
        return radialSum >= distance;
    }
}
